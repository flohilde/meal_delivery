<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>meal_delivery.src.vehicle API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>meal_delivery.src.vehicle</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from typing import Tuple


class Stop:
    r&#34;&#34;&#34;
    Stop in the route of a vehicle. A stop may describe the pickup of orders at a restaurant,
    the deliver of orders to a customer, or a relocation of the vehicle to a new location in the service area.

    Attributes
    ----------
    type : str
        String indicating the type of stop. Feasible types are &#39;pickup&#39;, &#39;delivery&#39;, &#39;relocation&#39;.
    destination : int
        Node at which the stop is located.
    customer_id : str or None
        Name of the customer where the delivery takes place, if type == &#39;delivery&#39;. ELse, None.
    restaurant_id : str or None
        Name of the restaurant where the pickup takes place, if type == &#39;pickup&#39;. ELse, None.
    start_at : int
        Earliest time at which the vehicle should leave its last location towards the stop.
    estimated_travel_time : int
        Estimated time (in seconds) required to drive from the last location to the stop.
    actual_travel_time : int
        Actual time (in seconds) required to drive from the last location to the stop.
    estimated_park_time : int
        Estimated time (in seconds) to park at the stop.
    actual_park_time : int
        Actual time (in seconds) to park at the stop.
    estimated_wait_time : int
        Estimated time to wait occurring in the synchronization process with the restaurant, i.e., wait time of the
        driver if the driver arrives before all orders to pickup are prepared by the restaurant.
    actual_wait_time : int
        Actual time to wait occurring in the synchronization process with the restaurant, i.e., wait time of the
        driver if the driver arrives before all orders to pickup are prepared by the restaurant.
    orders_to_pickup : list or None
        List of orders to pick up at the restaurant if the stop type is &#39;pickup&#39;. Else, None.
    &#34;&#34;&#34;

    def __init__(self, stop_type: str, destination: int, restaurant_id: str or None, customer_id: str or None,
                 start_at: int, estimated_travel_time: int, actual_travel_time: int, estimated_park_time: int,
                 actual_park_time: int, estimated_wait_time: int, actual_wait_time: int,
                 orders_to_pickup: list or None):
        assert stop_type in [&#34;pickup&#34;, &#34;delivery&#34;, &#34;relocation&#34;]
        if stop_type == &#34;pickup&#34;:
            assert orders_to_pickup is not None and orders_to_pickup
            assert restaurant_id is not None
            assert customer_id is None
        elif stop_type == &#34;delivery&#34;:
            assert estimated_wait_time == actual_wait_time == 0
            assert restaurant_id is None
            assert customer_id is not None
        else:
            assert estimated_wait_time == actual_wait_time == 0
            assert restaurant_id is None
            assert customer_id is None

        self.type = stop_type
        self.destination = destination
        self.customer_id = customer_id
        self.restaurant_id = restaurant_id
        self.start_at = start_at
        self.started_at = None
        self.estimated_travel_time = estimated_travel_time
        self.actual_travel_time = actual_travel_time
        self.estimated_park_time = estimated_park_time
        self.actual_park_time = actual_park_time
        self.estimated_wait_time = estimated_wait_time
        self.actual_wait_time = actual_wait_time
        self.orders_to_pickup = orders_to_pickup

    @property
    def estimated_total_time(self):
        r&#34;&#34;&#34;
        Returns the estimated time (in seconds) it takes to drive to the spot, find parking, and synchronize with the
        restaurant (if applicable).
        &#34;&#34;&#34;
        return self.estimated_travel_time + self.estimated_park_time + self.estimated_wait_time

    @property
    def actual_total_time(self):
        r&#34;&#34;&#34;
        Returns the actual time (in seconds) it takes to drive to the spot, find parking, and synchronize with the
        restaurant (if applicable).
        &#34;&#34;&#34;
        return self.estimated_travel_time + self.estimated_park_time + self.estimated_wait_time

    def summary(self):
        r&#34;&#34;&#34;
        Returns a summary of the vehicle as a dictionary. Only information that is known by the platform is contained.
        &#34;&#34;&#34;
        return {&#34;type&#34;: self.type,
                &#34;destination&#34;: self.destination,
                &#34;restaurant_id&#34;: self.restaurant_id,
                &#34;customer_id&#34;: self.customer_id,
                &#34;start_at&#34;: self.start_at,
                &#34;estimated_time_required&#34;: self.estimated_total_time,
                &#34;orders_to_pickup&#34;: self.orders_to_pickup}


class Vehicle:
    &#34;&#34;&#34;
    A vehicle picks up orders at the restaurants and delivers them to the corresponding customers.

    Parameters
    ----------
    id_number : int
            The id_number completes the vehicle name, given by &#34;v_{id_number}&#34;.
    location : int
        Node where the vehicle is currently idle or will be idle at the end of the route.

    Attributes
    ----------
    name : str
        Name of the vehicle. The name is used as a key to access the vehicle in the MealDeliveryMDP environment.
    location : int
        Node where the vehicle is currently idle or will be idle at the end of the route.
    sequence_of_stops : list[Stop]
        List of stops to sequentially traverse.
    orders_in_backpack : List[Tuple[str, str]]
        List of tuples containing restaurant name and customer name to identify orders that the vehicle is
        currently carrying.
    &#34;&#34;&#34;

    def __init__(self, id_number: int, location: int) -&gt; None:
        self.name = &#34;v_{}&#34;.format(id_number)
        self.location = int(location)  # current (or next) idle location of vehicle given by node in the graph
        self.sequence_of_stops = []  # list of stops to visit
        self.orders_in_backpack = []  # list of tuples (customer_id, restaurant_id)

    def update(self, time: int) -&gt; Tuple[dict, dict]:
        r&#34;&#34;&#34;
        Update the vehicle&#39;s route, i.e., sequence of stops by forwarding to the input time.

        Returns
        -------
        Returns a tuple containing a dict of orders that have been been picked up between the last time the vehicle&#39;s
        route was updated and the current time as well as a dict of orders that have been delivered to customers
        during this time period.
        &#34;&#34;&#34;
        picked_up = {}
        delivered = {}
        _time = time
        while self.sequence_of_stops:
            if self.sequence_of_stops[0].started_at is None:
                if -1 != self.sequence_of_stops[0].start_at &lt;= _time:
                    self.sequence_of_stops[0].started_at = self.sequence_of_stops[0].start_at
                else:
                    self.sequence_of_stops[0].started_at = _time
            _time = self.sequence_of_stops[0].started_at
            _time += self.sequence_of_stops[0].actual_total_time
            if _time &gt; time:
                break
            else:
                # stop has been visited and is removed
                stop = self.sequence_of_stops.pop(0)
                # if pickup stop, we remove the orders from the restaurant&#39;s prepared meals
                if stop.type == &#34;pickup&#34;:
                    picked_up[stop.restaurant_id] = stop.orders_to_pickup
                    self.orders_in_backpack.extend([(stop.restaurant_id, c_id) for c_id in stop.orders_to_pickup])
                # if delivery stop, we update the customer
                if stop.type == &#34;delivery&#34;:
                    delivered[stop.customer_id] = [(r_id, _time) for (r_id, c_id) in self.orders_in_backpack
                                                   if c_id == stop.customer_id]
        return picked_up, delivered

    def estimated_busy_time(self, current_time: int) -&gt; int:
        r&#34;&#34;&#34;
        Returns an estimated time required to perform all stops in the current route.
        &#34;&#34;&#34;
        if self.sequence_of_stops:
            t_diff = 0
            if self.sequence_of_stops[0].started_at is not None:
                t_diff = self.sequence_of_stops[0].started_at - current_time
            return sum([stop.estimated_total_time for stop in self.sequence_of_stops]) + t_diff
        else:
            return 0

    def summary(self, time) -&gt; dict:
        r&#34;&#34;&#34;
        Returns a summary of the vehicle as a dictionary. Only information that is known by the platform is contained.
        &#34;&#34;&#34;
        return {&#34;next_location&#34;: self.location,
                &#34;orders_in_backpack&#34;: self.orders_in_backpack,
                &#34;sequence_of_actions&#34;: [action.summary() for action in self.sequence_of_stops],
                &#34;busy_time&#34;: self.estimated_busy_time(time)}</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="meal_delivery.src.vehicle.Stop"><code class="flex name class">
<span>class <span class="ident">Stop</span></span>
<span>(</span><span>stop_type: str, destination: int, restaurant_id: str, customer_id: str, start_at: int, estimated_travel_time: int, actual_travel_time: int, estimated_park_time: int, actual_park_time: int, estimated_wait_time: int, actual_wait_time: int, orders_to_pickup: list)</span>
</code></dt>
<dd>
<div class="desc"><p>Stop in the route of a vehicle. A stop may describe the pickup of orders at a restaurant,
the deliver of orders to a customer, or a relocation of the vehicle to a new location in the service area.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>type</code></strong> :&ensp;<code>str</code></dt>
<dd>String indicating the type of stop. Feasible types are 'pickup', 'delivery', 'relocation'.</dd>
<dt><strong><code>destination</code></strong> :&ensp;<code>int</code></dt>
<dd>Node at which the stop is located.</dd>
<dt><strong><code>customer_id</code></strong> :&ensp;<code>str</code> or <code>None</code></dt>
<dd>Name of the customer where the delivery takes place, if type == 'delivery'. ELse, None.</dd>
<dt><strong><code>restaurant_id</code></strong> :&ensp;<code>str</code> or <code>None</code></dt>
<dd>Name of the restaurant where the pickup takes place, if type == 'pickup'. ELse, None.</dd>
<dt><strong><code>start_at</code></strong> :&ensp;<code>int</code></dt>
<dd>Earliest time at which the vehicle should leave its last location towards the stop.</dd>
<dt><strong><code>estimated_travel_time</code></strong> :&ensp;<code>int</code></dt>
<dd>Estimated time (in seconds) required to drive from the last location to the stop.</dd>
<dt><strong><code>actual_travel_time</code></strong> :&ensp;<code>int</code></dt>
<dd>Actual time (in seconds) required to drive from the last location to the stop.</dd>
<dt><strong><code>estimated_park_time</code></strong> :&ensp;<code>int</code></dt>
<dd>Estimated time (in seconds) to park at the stop.</dd>
<dt><strong><code>actual_park_time</code></strong> :&ensp;<code>int</code></dt>
<dd>Actual time (in seconds) to park at the stop.</dd>
<dt><strong><code>estimated_wait_time</code></strong> :&ensp;<code>int</code></dt>
<dd>Estimated time to wait occurring in the synchronization process with the restaurant, i.e., wait time of the
driver if the driver arrives before all orders to pickup are prepared by the restaurant.</dd>
<dt><strong><code>actual_wait_time</code></strong> :&ensp;<code>int</code></dt>
<dd>Actual time to wait occurring in the synchronization process with the restaurant, i.e., wait time of the
driver if the driver arrives before all orders to pickup are prepared by the restaurant.</dd>
<dt><strong><code>orders_to_pickup</code></strong> :&ensp;<code>list</code> or <code>None</code></dt>
<dd>List of orders to pick up at the restaurant if the stop type is 'pickup'. Else, None.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Stop:
    r&#34;&#34;&#34;
    Stop in the route of a vehicle. A stop may describe the pickup of orders at a restaurant,
    the deliver of orders to a customer, or a relocation of the vehicle to a new location in the service area.

    Attributes
    ----------
    type : str
        String indicating the type of stop. Feasible types are &#39;pickup&#39;, &#39;delivery&#39;, &#39;relocation&#39;.
    destination : int
        Node at which the stop is located.
    customer_id : str or None
        Name of the customer where the delivery takes place, if type == &#39;delivery&#39;. ELse, None.
    restaurant_id : str or None
        Name of the restaurant where the pickup takes place, if type == &#39;pickup&#39;. ELse, None.
    start_at : int
        Earliest time at which the vehicle should leave its last location towards the stop.
    estimated_travel_time : int
        Estimated time (in seconds) required to drive from the last location to the stop.
    actual_travel_time : int
        Actual time (in seconds) required to drive from the last location to the stop.
    estimated_park_time : int
        Estimated time (in seconds) to park at the stop.
    actual_park_time : int
        Actual time (in seconds) to park at the stop.
    estimated_wait_time : int
        Estimated time to wait occurring in the synchronization process with the restaurant, i.e., wait time of the
        driver if the driver arrives before all orders to pickup are prepared by the restaurant.
    actual_wait_time : int
        Actual time to wait occurring in the synchronization process with the restaurant, i.e., wait time of the
        driver if the driver arrives before all orders to pickup are prepared by the restaurant.
    orders_to_pickup : list or None
        List of orders to pick up at the restaurant if the stop type is &#39;pickup&#39;. Else, None.
    &#34;&#34;&#34;

    def __init__(self, stop_type: str, destination: int, restaurant_id: str or None, customer_id: str or None,
                 start_at: int, estimated_travel_time: int, actual_travel_time: int, estimated_park_time: int,
                 actual_park_time: int, estimated_wait_time: int, actual_wait_time: int,
                 orders_to_pickup: list or None):
        assert stop_type in [&#34;pickup&#34;, &#34;delivery&#34;, &#34;relocation&#34;]
        if stop_type == &#34;pickup&#34;:
            assert orders_to_pickup is not None and orders_to_pickup
            assert restaurant_id is not None
            assert customer_id is None
        elif stop_type == &#34;delivery&#34;:
            assert estimated_wait_time == actual_wait_time == 0
            assert restaurant_id is None
            assert customer_id is not None
        else:
            assert estimated_wait_time == actual_wait_time == 0
            assert restaurant_id is None
            assert customer_id is None

        self.type = stop_type
        self.destination = destination
        self.customer_id = customer_id
        self.restaurant_id = restaurant_id
        self.start_at = start_at
        self.started_at = None
        self.estimated_travel_time = estimated_travel_time
        self.actual_travel_time = actual_travel_time
        self.estimated_park_time = estimated_park_time
        self.actual_park_time = actual_park_time
        self.estimated_wait_time = estimated_wait_time
        self.actual_wait_time = actual_wait_time
        self.orders_to_pickup = orders_to_pickup

    @property
    def estimated_total_time(self):
        r&#34;&#34;&#34;
        Returns the estimated time (in seconds) it takes to drive to the spot, find parking, and synchronize with the
        restaurant (if applicable).
        &#34;&#34;&#34;
        return self.estimated_travel_time + self.estimated_park_time + self.estimated_wait_time

    @property
    def actual_total_time(self):
        r&#34;&#34;&#34;
        Returns the actual time (in seconds) it takes to drive to the spot, find parking, and synchronize with the
        restaurant (if applicable).
        &#34;&#34;&#34;
        return self.estimated_travel_time + self.estimated_park_time + self.estimated_wait_time

    def summary(self):
        r&#34;&#34;&#34;
        Returns a summary of the vehicle as a dictionary. Only information that is known by the platform is contained.
        &#34;&#34;&#34;
        return {&#34;type&#34;: self.type,
                &#34;destination&#34;: self.destination,
                &#34;restaurant_id&#34;: self.restaurant_id,
                &#34;customer_id&#34;: self.customer_id,
                &#34;start_at&#34;: self.start_at,
                &#34;estimated_time_required&#34;: self.estimated_total_time,
                &#34;orders_to_pickup&#34;: self.orders_to_pickup}</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="meal_delivery.src.vehicle.Stop.actual_total_time"><code class="name">var <span class="ident">actual_total_time</span></code></dt>
<dd>
<div class="desc"><p>Returns the actual time (in seconds) it takes to drive to the spot, find parking, and synchronize with the
restaurant (if applicable).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def actual_total_time(self):
    r&#34;&#34;&#34;
    Returns the actual time (in seconds) it takes to drive to the spot, find parking, and synchronize with the
    restaurant (if applicable).
    &#34;&#34;&#34;
    return self.estimated_travel_time + self.estimated_park_time + self.estimated_wait_time</code></pre>
</details>
</dd>
<dt id="meal_delivery.src.vehicle.Stop.estimated_total_time"><code class="name">var <span class="ident">estimated_total_time</span></code></dt>
<dd>
<div class="desc"><p>Returns the estimated time (in seconds) it takes to drive to the spot, find parking, and synchronize with the
restaurant (if applicable).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def estimated_total_time(self):
    r&#34;&#34;&#34;
    Returns the estimated time (in seconds) it takes to drive to the spot, find parking, and synchronize with the
    restaurant (if applicable).
    &#34;&#34;&#34;
    return self.estimated_travel_time + self.estimated_park_time + self.estimated_wait_time</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="meal_delivery.src.vehicle.Stop.summary"><code class="name flex">
<span>def <span class="ident">summary</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a summary of the vehicle as a dictionary. Only information that is known by the platform is contained.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def summary(self):
    r&#34;&#34;&#34;
    Returns a summary of the vehicle as a dictionary. Only information that is known by the platform is contained.
    &#34;&#34;&#34;
    return {&#34;type&#34;: self.type,
            &#34;destination&#34;: self.destination,
            &#34;restaurant_id&#34;: self.restaurant_id,
            &#34;customer_id&#34;: self.customer_id,
            &#34;start_at&#34;: self.start_at,
            &#34;estimated_time_required&#34;: self.estimated_total_time,
            &#34;orders_to_pickup&#34;: self.orders_to_pickup}</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="meal_delivery.src.vehicle.Vehicle"><code class="flex name class">
<span>class <span class="ident">Vehicle</span></span>
<span>(</span><span>id_number: int, location: int)</span>
</code></dt>
<dd>
<div class="desc"><p>A vehicle picks up orders at the restaurants and delivers them to the corresponding customers.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>id_number</code></strong> :&ensp;<code>int</code></dt>
<dd>The id_number completes the vehicle name, given by "v_{id_number}".</dd>
<dt><strong><code>location</code></strong> :&ensp;<code>int</code></dt>
<dd>Node where the vehicle is currently idle or will be idle at the end of the route.</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the vehicle. The name is used as a key to access the vehicle in the MealDeliveryMDP environment.</dd>
<dt><strong><code>location</code></strong> :&ensp;<code>int</code></dt>
<dd>Node where the vehicle is currently idle or will be idle at the end of the route.</dd>
<dt><strong><code>sequence_of_stops</code></strong> :&ensp;<code>list[<a title="meal_delivery.src.vehicle.Stop" href="#meal_delivery.src.vehicle.Stop">Stop</a>]</code></dt>
<dd>List of stops to sequentially traverse.</dd>
<dt><strong><code>orders_in_backpack</code></strong> :&ensp;<code>List[Tuple[str, str]]</code></dt>
<dd>List of tuples containing restaurant name and customer name to identify orders that the vehicle is
currently carrying.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Vehicle:
    &#34;&#34;&#34;
    A vehicle picks up orders at the restaurants and delivers them to the corresponding customers.

    Parameters
    ----------
    id_number : int
            The id_number completes the vehicle name, given by &#34;v_{id_number}&#34;.
    location : int
        Node where the vehicle is currently idle or will be idle at the end of the route.

    Attributes
    ----------
    name : str
        Name of the vehicle. The name is used as a key to access the vehicle in the MealDeliveryMDP environment.
    location : int
        Node where the vehicle is currently idle or will be idle at the end of the route.
    sequence_of_stops : list[Stop]
        List of stops to sequentially traverse.
    orders_in_backpack : List[Tuple[str, str]]
        List of tuples containing restaurant name and customer name to identify orders that the vehicle is
        currently carrying.
    &#34;&#34;&#34;

    def __init__(self, id_number: int, location: int) -&gt; None:
        self.name = &#34;v_{}&#34;.format(id_number)
        self.location = int(location)  # current (or next) idle location of vehicle given by node in the graph
        self.sequence_of_stops = []  # list of stops to visit
        self.orders_in_backpack = []  # list of tuples (customer_id, restaurant_id)

    def update(self, time: int) -&gt; Tuple[dict, dict]:
        r&#34;&#34;&#34;
        Update the vehicle&#39;s route, i.e., sequence of stops by forwarding to the input time.

        Returns
        -------
        Returns a tuple containing a dict of orders that have been been picked up between the last time the vehicle&#39;s
        route was updated and the current time as well as a dict of orders that have been delivered to customers
        during this time period.
        &#34;&#34;&#34;
        picked_up = {}
        delivered = {}
        _time = time
        while self.sequence_of_stops:
            if self.sequence_of_stops[0].started_at is None:
                if -1 != self.sequence_of_stops[0].start_at &lt;= _time:
                    self.sequence_of_stops[0].started_at = self.sequence_of_stops[0].start_at
                else:
                    self.sequence_of_stops[0].started_at = _time
            _time = self.sequence_of_stops[0].started_at
            _time += self.sequence_of_stops[0].actual_total_time
            if _time &gt; time:
                break
            else:
                # stop has been visited and is removed
                stop = self.sequence_of_stops.pop(0)
                # if pickup stop, we remove the orders from the restaurant&#39;s prepared meals
                if stop.type == &#34;pickup&#34;:
                    picked_up[stop.restaurant_id] = stop.orders_to_pickup
                    self.orders_in_backpack.extend([(stop.restaurant_id, c_id) for c_id in stop.orders_to_pickup])
                # if delivery stop, we update the customer
                if stop.type == &#34;delivery&#34;:
                    delivered[stop.customer_id] = [(r_id, _time) for (r_id, c_id) in self.orders_in_backpack
                                                   if c_id == stop.customer_id]
        return picked_up, delivered

    def estimated_busy_time(self, current_time: int) -&gt; int:
        r&#34;&#34;&#34;
        Returns an estimated time required to perform all stops in the current route.
        &#34;&#34;&#34;
        if self.sequence_of_stops:
            t_diff = 0
            if self.sequence_of_stops[0].started_at is not None:
                t_diff = self.sequence_of_stops[0].started_at - current_time
            return sum([stop.estimated_total_time for stop in self.sequence_of_stops]) + t_diff
        else:
            return 0

    def summary(self, time) -&gt; dict:
        r&#34;&#34;&#34;
        Returns a summary of the vehicle as a dictionary. Only information that is known by the platform is contained.
        &#34;&#34;&#34;
        return {&#34;next_location&#34;: self.location,
                &#34;orders_in_backpack&#34;: self.orders_in_backpack,
                &#34;sequence_of_actions&#34;: [action.summary() for action in self.sequence_of_stops],
                &#34;busy_time&#34;: self.estimated_busy_time(time)}</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="meal_delivery.src.vehicle.Vehicle.estimated_busy_time"><code class="name flex">
<span>def <span class="ident">estimated_busy_time</span></span>(<span>self, current_time: int) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Returns an estimated time required to perform all stops in the current route.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def estimated_busy_time(self, current_time: int) -&gt; int:
    r&#34;&#34;&#34;
    Returns an estimated time required to perform all stops in the current route.
    &#34;&#34;&#34;
    if self.sequence_of_stops:
        t_diff = 0
        if self.sequence_of_stops[0].started_at is not None:
            t_diff = self.sequence_of_stops[0].started_at - current_time
        return sum([stop.estimated_total_time for stop in self.sequence_of_stops]) + t_diff
    else:
        return 0</code></pre>
</details>
</dd>
<dt id="meal_delivery.src.vehicle.Vehicle.summary"><code class="name flex">
<span>def <span class="ident">summary</span></span>(<span>self, time) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a summary of the vehicle as a dictionary. Only information that is known by the platform is contained.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def summary(self, time) -&gt; dict:
    r&#34;&#34;&#34;
    Returns a summary of the vehicle as a dictionary. Only information that is known by the platform is contained.
    &#34;&#34;&#34;
    return {&#34;next_location&#34;: self.location,
            &#34;orders_in_backpack&#34;: self.orders_in_backpack,
            &#34;sequence_of_actions&#34;: [action.summary() for action in self.sequence_of_stops],
            &#34;busy_time&#34;: self.estimated_busy_time(time)}</code></pre>
</details>
</dd>
<dt id="meal_delivery.src.vehicle.Vehicle.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, time: int) ‑> Tuple[dict, dict]</span>
</code></dt>
<dd>
<div class="desc"><p>Update the vehicle's route, i.e., sequence of stops by forwarding to the input time.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Returns a tuple containing a dict</code> of <code>orders that have been been picked up between the last time the vehicle's</code></dt>
<dd>&nbsp;</dd>
<dt><code>route was updated and the current time as well as a dict</code> of <code>orders that have been delivered to customers</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>during this time period.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self, time: int) -&gt; Tuple[dict, dict]:
    r&#34;&#34;&#34;
    Update the vehicle&#39;s route, i.e., sequence of stops by forwarding to the input time.

    Returns
    -------
    Returns a tuple containing a dict of orders that have been been picked up between the last time the vehicle&#39;s
    route was updated and the current time as well as a dict of orders that have been delivered to customers
    during this time period.
    &#34;&#34;&#34;
    picked_up = {}
    delivered = {}
    _time = time
    while self.sequence_of_stops:
        if self.sequence_of_stops[0].started_at is None:
            if -1 != self.sequence_of_stops[0].start_at &lt;= _time:
                self.sequence_of_stops[0].started_at = self.sequence_of_stops[0].start_at
            else:
                self.sequence_of_stops[0].started_at = _time
        _time = self.sequence_of_stops[0].started_at
        _time += self.sequence_of_stops[0].actual_total_time
        if _time &gt; time:
            break
        else:
            # stop has been visited and is removed
            stop = self.sequence_of_stops.pop(0)
            # if pickup stop, we remove the orders from the restaurant&#39;s prepared meals
            if stop.type == &#34;pickup&#34;:
                picked_up[stop.restaurant_id] = stop.orders_to_pickup
                self.orders_in_backpack.extend([(stop.restaurant_id, c_id) for c_id in stop.orders_to_pickup])
            # if delivery stop, we update the customer
            if stop.type == &#34;delivery&#34;:
                delivered[stop.customer_id] = [(r_id, _time) for (r_id, c_id) in self.orders_in_backpack
                                               if c_id == stop.customer_id]
    return picked_up, delivered</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="meal_delivery.src" href="index.html">meal_delivery.src</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="meal_delivery.src.vehicle.Stop" href="#meal_delivery.src.vehicle.Stop">Stop</a></code></h4>
<ul class="">
<li><code><a title="meal_delivery.src.vehicle.Stop.actual_total_time" href="#meal_delivery.src.vehicle.Stop.actual_total_time">actual_total_time</a></code></li>
<li><code><a title="meal_delivery.src.vehicle.Stop.estimated_total_time" href="#meal_delivery.src.vehicle.Stop.estimated_total_time">estimated_total_time</a></code></li>
<li><code><a title="meal_delivery.src.vehicle.Stop.summary" href="#meal_delivery.src.vehicle.Stop.summary">summary</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="meal_delivery.src.vehicle.Vehicle" href="#meal_delivery.src.vehicle.Vehicle">Vehicle</a></code></h4>
<ul class="">
<li><code><a title="meal_delivery.src.vehicle.Vehicle.estimated_busy_time" href="#meal_delivery.src.vehicle.Vehicle.estimated_busy_time">estimated_busy_time</a></code></li>
<li><code><a title="meal_delivery.src.vehicle.Vehicle.summary" href="#meal_delivery.src.vehicle.Vehicle.summary">summary</a></code></li>
<li><code><a title="meal_delivery.src.vehicle.Vehicle.update" href="#meal_delivery.src.vehicle.Vehicle.update">update</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>